/*------------------------------------------------------------------------------
  Copyright (c) Foxfire Technologies (India) Ltd.  All rights reserved

  Revision History:

  Date        Person  Comments

  2020/04/01  TK      pr_Receipts_ReceiveInventory & pr_Receipts_UI_ReceiveToLPN:
  2020/03/19  TK      pr_Receipts_UI_ReceiveToLPN & pr_Receipts_ReceiveInventory:
  2020/03/17  TK      pr_Receipts_UI_ReceiveToLPN: Get the range of LPNs generated by LPN instead of LPNId (S2GCA-1110)
  SV      pr_Receipts_ReceiveInventory, pr_Receipts_UI_ReceiveToLPN:
  2018/05/25  CK      pr_Receipts_UI_ReceiveToLPN: Added validation for non standard cases while receiving LPN in cases (S2G-841)
  pr_Receipts_UI_ReceiveToLPN: moved the over receiving related changes to function (S2G-811)
  2018/05/01  TK      pr_Receipts_UI_ReceiveToLPN: Fix to consider proper Innerpacks while receiving LPNs (S2G-767)
  2018/02/06  SV      pr_Receipts_UI_ReceiveToLPN: Need to allow users(of allowed role permissions) to create LPNs as many times (S2G-154)
  2017/06/14  TK      pr_Receipts_UI_ReceiveToLPN: Bug fix to consider LPNs generated for that perticular Receipt only (CIMS-1463)
  2017/02/15  KL      pr_Receipts_UI_ReceiveToLPN: Added code to update pallet counts when user opted generate pallet option,
  2016/10/27  ??      pr_Receipts_UI_ReceiveToLPN: Commented out check condition for ReceiptType Special Order (HPI-GoLive)
  2016/10/24  OK      pr_Receipts_UI_ReceiveToLPN: enhanced to restrict the reciving against special PO if PickTicket is not valid (HPI-908)
  2016/10/18  SV      pr_Receipts_UI_ReceiveToLPN: Added Transaction controls (HPI-881)
  2016/09/23  SV/VM   pr_Receipts_UI_ReceiveToLPN: Allow over receiving based on Role permissions (HPI-732)
  2016/07/20  SV      pr_Receipts_UI_ReceiveToLPN: Set Owner on LPN from RD or RH or sent from UI (HPI-330).
  2016/06/23  VM      pr_Receipts_UI_ReceiveToLPN: Send Innerpack details as well to AT (HPI-171)
  2016/04/06  AY      pr_Receipts_UI_ReceiveToLPN, pr_Receipts_ReceiveInventory: Get CoO from RD to apply to LPNs created
  2016/03/18  DK      pr_Receipts_UI_ReceiveToLPN: Corrected CreateLPNsToReceive_Pallet message description (NBD-277).
  2016/03/07  TD      pr_Receipts_UI_ReceiveToLPN: fix to allow users to receive in eaches
  2016/02/03  TK      pr_Receipts_UI_ReceiveToLPN: Consider Innerpacks/Cases value(NBD-136)
  2016/01/20  TD      pr_Receipts_UI_ReceiveToLPN:Changes to validate UnitsPerLPN agaist user given value.
  2016/01/12  DK      pr_Receipts_UI_ReceiveToLPN: Bug fix to consider Quantity greater than zero while creating Inventory (FB-598).
  2015/12/23  SV      pr_Receipts_UI_ReceiveToLPN: Bug fix - restrict to create more inventory than the maxiumum allowed (FB-175)
  2015/11/26  DK      pr_Receipts_UI_ReceiveToLPN: Bug fix to consider Warehouse on receipt header if Warehouse from UI is null (FB-542).
  2015/05/12  SV      pr_Receipts_UI_ReceiveToLPN: Made changes to show the Receipt # over the LPN and recounted the Qty over receipts
  2015/05/11  SV      pr_Receipts_UI_ReceiveToLPN: Made changes to proceed Receive to LPN with Intransit Receipts
------------------------------------------------------------------------------*/

Go

if object_id('dbo.pr_Receipts_UI_ReceiveToLPN') is not null
  drop Procedure pr_Receipts_UI_ReceiveToLPN;
Go
/*------------------------------------------------------------------------------
  Proc pr_Receipts_UI_ReceiveToLPN:
    <ReceivingDetails>
      <Header>
        <ReceiverNumber></ReceiverNumber>
        <ReceiptId></ReceiptId>
        <Location></Location>
        <Pallet></Pallet>
        <Warehouse></Warehouse>
        <GeneratePallet></GeneratePallet>
      </Header>
      <Details>
        <Detail>
          <ReceiptDetailId>57</ReceiptDetailId>
          <SKUId></SKUId>
          <NumPallets></NumPallets>
          <LPNsPerPallet></LPNsPerPallet>
          <QtyPerLPN></QtyPerLPN>
          <Owner></Owner>
          <COO></COO>
         </Detail>
         ...
         ...
      </Details>
    </ReceivingDetails>

    First of all, this is not a wrapper procedure and for each SKU selection from
    UI this procedure is being called. hence there won't be multiple details as
    mentioned in the above sample.
------------------------------------------------------------------------------*/
Create Procedure pr_Receipts_UI_ReceiveToLPN
  (@ReceivingDetails   TXML,
   @BusinessUnit       TBusinessUnit,
   @UserId             TUserId,
   @xmlResult          TXML output)
as
  declare @ReturnCode              TInteger,
          @MessageName             TMessageName,

          @vRecordId               TRecordId,
          @vReceiptId              TRecordId,
          @vReceiverNumber         TReceiverNumber,
          @vReceiverId             TRecordId,
          @vReceiptNumber          TReceiptNumber,
          @vReceiptType            TReceiptType,
          @vReceiptStatus          TStatus,
          @vReceiptDetailId        TRecordId,
          @vReceiptLine            TReceiptLine,
          @vPickTicket             TPickTicket,
          @vPalletStatus           TStatus,
          @vReceiptWarehouse       TWarehouse,
          @vPalletWarehouse        TWarehouse,
          @vPalletType             TTypeCode,
          @vSKUId                  TRecordId,
          @vSKU                    TSKU,
          @vInnerPacks             TQuantity,
          @vRemainingAllowedQtyToRecv
                                   TQuantity,
          @vRemainingMaxAllowedQtyToRecv
                                   TQuantity,
          @vQtyPerLPN              TQuantity,
          @vSKUAndPallet           TVarchar,
          @vUnitsPerLPN            TQuantity,
          @vUnitsPerInnerPack      TQuantity,
          @vMaxQtyAllowedToReceive TQuantity,
          @vTotalQtyToReceive      TQuantity,
          @vLocationId             TRecordId,
          @vLocation               TLocation,
          @vLocationType           TLocationType,
          @vWarehouse              TWarehouse,
          @vCustPO                 TCustPO,
          @vPallet                 TPallet,
          @vPalletId               TRecordId,
          @vLPNId                  TRecordId,
          @vLPNDetailId            TRecordId,
          @vLPNRecordId            TRecordId,

          @vLPN                    TLPN,
          @vUpdatedRODetailCount   TCount,
          @vTotalQtyToCreate       TCount,
          @vReceiveToPallet        TFlag,
          @PalletCount             TCount,
          @vPalletCount            TCount,
          @vFirstPalletId          TRecordId,
          @vLastLPNId              TRecordId,
          @vLPNsPerPallet          TCount,
          @vFirstLPNId             TRecordId,
          @FirstLPNId              TRecordId,
          @vFirstLPN               TLPN,
          @vLastLPN                TLPN,
          @vNumPalletReceived      TQuantity,
          @vNumLPNsReceived        TQuantity,
          @vNumUnitsReceived       TQuantity,
          @vNumLPNsCreated         TCount,
          @vLPNXML                 TXML,
          @vOwner                  TOwnership,
          @vCoO                    TCoO,
          @vInventoryClass1        TInventoryClass,
          @vInventoryClass2        TInventoryClass,
          @vInventoryClass3        TInventoryClass,

          @vAuditActivity          TActivityType,
          @vMessage                TMessage,
          @xmlRODetails            xml,
          @xmlLPNsGenerated        TXML,
          @vGeneratePallet         TFlag,
          @vSKUUnitsPerInnerPack   TQuantity,
          @vUnitsPercase           TQuantity,

          @vAllowNonStandardPackConfig
                                   TControlValue;

  declare @ttReceiptDetails table(RecordId               TRecordId Identity(1,1),
                                  ReceiptDetailId        TRecordId,
                                  SKUId                  TRecordId,
                                  NumPallets             TCount,
                                  LPNsPerPallet          TQuantity,
                                  InnerPacksPerLPN       TQuantity,
                                  UnitsPerInnerPack      TQuantity,
                                  QtyPerLPN              TQuantity,
                                  MaxQtyAllowedToReceive TQuantity,
                                  Owner                  TOwnership,
                                  CoO                    TCoO,
                                  InventoryClass1        TInventoryClass,
                                  InventoryClass2        TInventoryClass,
                                  InventoryClass3        TInventoryClass,

                                  Processed              TFlag);
  declare @ttLPNs TEntityKeysTable;
begin
begin try
  begin transaction;

  select @vLPNsPerPallet = 0,
         @vRecordId      = 0,
         @xmlRODetails   = convert(xml, @ReceivingDetails);

  /* Get control value on allowing Non-Standard Pack Config */
  select @vAllowNonStandardPackConfig = dbo.fn_Controls_GetAsString('LPN_INV', 'AllowNonStandardPackConfig', 'N', @BusinessUnit, @UserId);

  /* Get Header info */
  select @vReceiverNumber = Record.Col.value('ReceiverNumber[1]',  'TReceiverNumber'),
         @vReceiptId      = Record.Col.value('ReceiptId[1]',       'TRecordId'),
         @vLocation       = nullif(Record.Col.value('Location[1]', 'TLocation'), ''),
         @vPallet         = nullif(Record.Col.value('Pallet[1]',   'TPallet'), ''),
         @vWarehouse      = nullif(Record.Col.value('Warehouse[1]','TWarehouse'), ''),
         @vGeneratePallet = Record.Col.value('GeneratePallet[1]',  'TFlag')
  from @xmlRODetails.nodes('/ReceivingDetails/Header') as Record(Col);

  select @vSKUId          = Record.Col.value('SKUId[1]',        'TRecordId'),
         @vQtyPerLPN      = Record.Col.value('QtyPerLPN[1]',    'TQuantity'),
         @vUnitsPerCase   = Record.Col.value('UnitsPerCase[1]', 'TQuantity')
  from @xmlRODetails.nodes('/ReceivingDetails/Details/Detail') as Record(Col);

  /* Take all details/lines into a temp table */
  insert into @ttReceiptDetails (ReceiptDetailId, SKUId, NumPallets, LPNsPerPallet, InnerPacksPerLPN, UnitsPerInnerPack,
                                 QtyPerLPN, MaxQtyAllowedToReceive, Owner, CoO, Processed)
    select Record.Col.value('ReceiptDetailId[1]' , 'TRecordId'),
           Record.Col.value('SKUId[1]'           , 'TRecordId'),
           Record.Col.value('NoOfPallets[1]'     , 'TCount'),
           Record.Col.value('LPNsPerPallet[1]'   , 'TQuantity'),
           Record.Col.value('CasesPerLPN[1]'     , 'TQuantity'),
           Record.Col.value('UnitsPerCase[1]'    , 'TQuantity'),
           Record.Col.value('QtyPerLPN[1]'       , 'TQuantity'),
           0 /* MaxQtyAllowedToReceive - we will update it later by joining with receipt detail */,
           Record.Col.value('Owner[1]'           , 'TOwnership'),
           Record.Col.value('CoO[1]'             , 'TCoO'),
           'N' /* No */
    from @xmlRODetails.nodes('/ReceivingDetails/Details/Detail') as Record(Col);

  /* Update details temp table with MaxQtyToAllowedToReceive */
  update ttRD
  set Owner                    = coalesce(nullif(RD.Ownership, ''), RH.Ownership, Owner), /* Owner would be picked from receipt detail, not headers */
      CoO                      = RD.CoO,
      InventoryClass1          = RD.InventoryClass1,
      InventoryClass2          = RD.InventoryClass2,
      InventoryClass3          = RD.InventoryClass3,
      MaxQtyAllowedToReceive   = ((RD.QtyOrdered + RD.ExtraQtyAllowed) - RD.QtyInTransit),
      @vReceiptDetailId        = ttRD.ReceiptDetailId, --We can receive against only one ReceiptDetail
      @vMaxQtyAllowedToReceive = ((RD.QtyOrdered + RD.ExtraQtyAllowed) - RD.QtyInTransit),
      @vLPNsPerPallet          = ttRD.LPNsPerPallet,
      @vTotalQtyToCreate       = ttRD.LPNsPerPallet * ttRD.QtyPerLPN,
      @vQtyPerLPN              = ttRD.QtyPerLPN,
      @vInnerPacks             = ttRD.InnerPacksPerLPN,
      @vUnitsPerInnerPack      = ttRD.UnitsPerInnerPack,
      @vRemainingAllowedQtyToRecv    = (RD.QtyToReceive - RD.QtyInTransit),
      @vRemainingMaxAllowedQtyToRecv = ((RD.QtyToReceive + RD.ExtraQtyAllowed) - RD.QtyInTransit)
  from @ttReceiptDetails ttRD
    join ReceiptDetails RD on (ttRD.ReceiptDetailId = RD.ReceiptDetailId)
    join ReceiptHeaders RH on (RH.ReceiptId = RD.ReceiptId);

  /* Get the Options - required? might not be - VM_20140204
  select @vGeneratePallets = Record.Col.value('GeneratePallets[1]', 'TFlag')
  from @xmlRODetails.nodes('/RECEIVINGDETAILS/OPTIONS') as Record(Col); */

  /* Validations */
  /* Fetch Receipt info */
  select @vReceiptId        = ReceiptId,
         @vReceiptNumber    = ReceiptNumber,
         @vReceiptStatus    = Status,
         @vReceiptType      = ReceiptType,
         @vReceiptWarehouse = Warehouse,
         @vWarehouse        = coalesce(@vWarehouse, Warehouse),
         @vPickTicket       = PickTicket
  from ReceiptHeaders
  where (ReceiptId    = @vReceiptId) and
        (BusinessUnit = @BusinessUnit);

  /* Get ReceiverId using ReceiverNumber, */
  select @vReceiverId = ReceiverId
  from Receivers
  where (ReceiverNumber = @vReceiverNumber) and
        (BusinessUnit   = @BusinessUnit);

  /* VM_20140306 - Need to validate Receiver status as well but Receiver changes are on hold, we will do that later
     RECEIVER VALIDATION HERE !!!!!!!!!
   */
  /* Fetch Location info */
  select @vLocationId   = LocationId,
         @vLocationType = LocationType
  from Locations
  where (Location     = @vLocation) and
        (BusinessUnit = @BusinessUnit);

  /* Fetch Pallet Info */
  if (@vPallet is not null)
    begin
      select @vPalletId        = PalletId,
             @vPalletStatus    = Status,
             @vPalletType      = PalletType,
             @vPalletWarehouse = Warehouse
      from Pallets
      where (Pallet       = @vPallet) and
            (BusinessUnit = @BusinessUnit);

      /* If users picks a empty inventory pallet, change it to receiving pallet */
      update Pallets
      set PalletType   = 'R' /* Receiving Pallet */,
          @vPalletType = 'R' /* Receiving Pallet */
      where ((PalletId     = @vPalletId) and
             (@vPalletType = 'I' /* Inventory Pallet */) and
             (Quantity     = 0));

      select @vPalletCount = 1; /* If user selects pallet, it would be one */
    end

  /* Validations */
  if (@vReceiptId is null)
    set @MessageName = 'ReceiptIsInvalid';
  else
  if (@vQtyPerLPN = 0)
    set @MessageName = 'QuantityCantBeZeroOrNull';
  else
  if (@vInnerPacks > 0) and (coalesce(@vUnitsPerInnerPack, 0) < 1)
    set @MessageName = 'InvalidPackConfig';
  else
  if (@vLocation is not null) and (@vLocationId is null)
    set @MessageName = 'LocationIsInvalid';
  else
  if ((@vPallet is not null) and (@vPalletId is null))
    set @MessageName = 'PalletDoesNotExist';
  else
  if ((@vPallet is not null) and (@vPalletType <> 'R' /* Receiving */))
    set @MessageName = 'NotAReceivingPallet';
  else
  if (@vPalletWarehouse <> @vReceiptWarehouse)
    set @MessageName = 'PalletsWarehouseMismatch';
  else
  if (@vReceiptStatus not in ('I' /* Initial */, 'T' /* InTransit */, 'R' /* Receiving */, 'E' /* Received */))
    set @MessageName = 'InvalidReceiptStatus';
  else
  -- if ((@vReceiptType = 'G' /* Special Order */) and
  --     ((coalesce(@vPickTicket, '') = '') or (not exists (select * from Orderheaders where SalesOrder = @vPickTicket))))
  --   set @MessageName = 'InvalidPickTicketToReceive';
  -- else
    set @MessageName = dbo.fn_Receipts_ValidateOverReceiving(@vReceiptDetailId, @vTotalQtyToCreate, @UserId);

  if (@MessageName is not null)
    goto ErrorHandler;

  /* This loop runs until LPNs created for all selected Receipt Details, Currently
     we are passing only one detail at a time. */
  while (exists (select * from @ttReceiptDetails where RecordId > @vRecordId))
    begin
      /* Fetch info from the details temp table */
      select top 1 @vRecordId               = RecordId,
                   @vReceiptDetailId        = ReceiptDetailId,
                   @vSKUId                  = SKUId,
                   @vPalletCount            = coalesce(@vPalletCount, NumPallets),
                   @PalletCount             = coalesce(@vPalletCount, NumPallets),
                   @vLPNsPerPallet          = LPNsPerPallet,
                   @vInnerPacks             = InnerPacksPerLPN,
                   @vQtyPerLPN              = QtyPerLPN,
                   @vMaxQtyAllowedToReceive = MaxQtyAllowedToReceive,
                   @vOwner                  = Owner,
                   @vCoO                    = CoO,
                   @vInventoryClass1        = InventoryClass1,
                   @vInventoryClass2        = InventoryClass2,
                   @vInventoryClass3        = InventoryClass3
      from @ttReceiptDetails
      where (RecordId > @vRecordId)
      order by RecordId;

      /* Fetching SKU info */
      select @vSKU                  = SKU,
             @vSKUUnitsPerInnerPack = coalesce(UnitsPerInnerPack, 0)
      from SKUs
      where (SKUId = @vSKUId);

      /* Restrict to receive Non-Standard Cases, if not allowed */
      if (@vAllowNonStandardPackConfig  = 'N' /* No */ ) and (@vUnitsPerCase <> @vSKUUnitsPerInnerPack)
        set @MessageName = 'NonStandardCasesNotAllowed';

      if (@vPalletCount = 0) and (@vPallet is null)
        set @vReceiveToPallet = 'N';
      else
        set @vReceiveToPallet = 'Y';

      /* Loop runs until all Pallets are generated, it runs for one time if pallet
         generation is not required */
      while ((@vPalletCount > 0) or
             ((@vPalletCount = 0) and
             (@vReceiveToPallet = 'N')))
        begin
          if (@vGeneratePallet = 'Y' /* Yes */)
            begin
              set  @vPalletType = 'I';

              /* Pallet generation */
              exec @ReturnCode = pr_Pallets_GeneratePalletLPNs @vPalletType,
                                                               1,
                                                               null /* PalletFormat */,
                                                               0 /* NumLPNsPerPallet */,
                                                               null /* LPNType */,
                                                               null /* LPNFormat */,
                                                               @vWarehouse,
                                                               @BusinessUnit,
                                                               @UserId,
                                                               @vPalletId output,
                                                               @vPallet   output;

              /* Update pallet type as receiving as we are generating pallet for receiving */
              update Pallets
              set PalletType = 'R'
              where palletid = @vPalletId

            end

         if (@ReturnCode > 0)
           goto ExitHandler;

         if (@vGeneratePallet = 'N' /* generate - No, User will scan */) and
            (@vPallet is not null) /* Validate, if Pallet is given */
           begin
             select @vPalletId     = PalletId,
                    @vPalletStatus = Status
             from Pallets
             where (Pallet       = @vPallet) and
                   (BusinessUnit = @Businessunit);

             if (@vPalletId is null)
               set @MessageName = 'LPN_CreateInvLPNs_InvalidPallet';
             else
             if (@vPalletStatus not in ('E' /* Empty */, 'R'/* Received */))
               set @MessageName = 'LPN_CreateInvLPNs_InvalidPalletStatus';
           end

          if (@MessageName is not null)
            goto ErrorHandler;

          /* Generating LPNs based on number of LPNs set on Pallet */
          exec @ReturnCode = pr_LPNs_Generate 'C',
                                              @vLPNsPerPallet,
                                              null,
                                              @vWarehouse,
                                              @BusinessUnit,
                                              @UserId,
                                              @vFirstLPNId output,
                                              @vFirstLPN  output /* FirstLPN */,
                                              @vLastLPNId output,
                                              @vLastLPN  output /* LastLPN */,
                                              @vNumLPNsCreated output /* NumLPNsCreated */,
                                              null /* Message */;
          if (@ReturnCode > 0)
            goto ErrorHandler;

          /* Here @FirstLPNId is a temporary variable, @vFirstLPNId will be change its
             value when it is in the while loop for updating SKU information on LPN. */
          set @FirstLPNId = @vFirstLPNId;

          /* Inserting newly generated LPNs into temp table for printing labels at UI side */
          insert into @ttLPNs (EntityId, EntityKey)
            select LPNId, LPN
            from LPNs
            where (LPN between @vFirstLPN and @vLastLPN) and
                  (LPNType = 'C'/* Carton */)    and
                  (BusinessUnit = @BusinessUnit) and
                  (CreatedBy = @UserId)
            order by LPN;

          /* Updating ReceiverNumber and other info on newly generated LPNs */
          update L
          set ReceiverId      = @vReceiverId,
              ReceiverNumber  = @vReceiverNumber,
              Status          = 'T' /* InTransit */,
              --LocationId     = @vLocationId,
              PalletId        = @vPalletId,
              Pallet          = @vPallet,
              Ownership       = @vOwner,
              ReceiptId       = @vReceiptId,
              ReceiptNumber   = @vReceiptNumber,
              InventoryClass1 = @vInventoryClass1,
              InventoryClass2 = @vInventoryClass2,
              InventoryClass3 = @vInventoryClass3
          from LPNs L
            join @ttLPNs ttL on (L.LPNId = ttL.EntityId);;

          /* Initialize */
          set @vLPNRecordId = 0;

          /* Adding SKU to LPN with given quantity */
          while exists(select * from @ttLPNs where RecordId > @vLPNRecordId)
            begin
              select top 1 @vLPNRecordId = RecordId,
                           @vFirstLPNId  = EntityId
              from @ttLPNs
              where (RecordId > @vLPNRecordId)
              order by RecordId;

              select @vLPNDetailId = null;

              exec pr_LPNDetails_AddOrUpdate @vFirstLPNId, /* LPNId */
                                             null, /* LPN Line */
                                             @vCoO, /* CoO */
                                             @vSKUId, /* SKUId */
                                             @vSKU, /*SKU */
                                             @vInnerPacks, /* InnerPacks */
                                             @vQtyPerLPN, /* Quantity */
                                             @vQtyPerLPN, /* ReceivedUnits */
                                             @vReceiptId, /* ReceiptId */
                                             @vReceiptDetailId, /* ReceiptDetailId */
                                             null, /* OrderId */
                                             null, /* OrderDetailId */
                                             null, /* OnhandStatus */
                                             null, /* Operation */
                                             null, /* Weight */
                                             null, /* Volume */
                                             null, /* Lot */
                                             @BusinessUnit, /* BusinessUnit */
                                             @vLPNDetailId output /* LPNDetailId */;

              if (@vPalletId is not null)
                set @vAuditActivity = 'CreateLPNToReceive_LPNsPallets';
              else
                set @vAuditActivity = 'CreateLPNToReceive_LPNs';

              /* Logging AT on LPN, Pallet in each iteration */
              exec pr_AuditTrail_Insert @vAuditActivity, @UserId, null /* ActivityTimestamp */,
                                        @BusinessUnit  = @BusinessUnit,
                                        @SKUId         = @vSKUId,
                                        @InnerPacks    = @vInnerPacks,
                                        @Quantity      = @vQtyPerLPN,
                                        --@LocationId    = @vLocationId,
                                        @ToLPNId       = @vFirstLPNId,
                                        @PalletId      = @vPalletId,
                                        @ReceiptId     = @vReceiptId;

              /* Add the Received Info to ReceivedCounts table */
              exec pr_ReceivedCounts_AddOrUpdate @vFirstLPNId, @vLPNDetailId, @vInnerPacks, @vQtyPerLPN,
                                                 @vReceiptId, @vReceiverId, @vReceiptDetailId,
                                                 @vPalletId, @vLocationId, @vSKUId,
                                                 '=' /*@UpdateOption */, @BusinessUnit, @UserId;
            end /* While .. Next LPN */

          /* Calculating TotalQty to update on Pallet. */
          select @vTotalQtyToReceive = @vQtyPerLPN  * @vLPNsPerPallet;

          if (@vPalletId is not null)
            begin
              /* Updating Location and other information on Pallet. */
              update Pallets
              set LocationId = @vLocationId,
                  Ownership  = @vOwner
              where PalletId = @vPalletId;

              exec @ReturnCode = pr_Pallets_UpdateCount @PalletId     = @vPalletId,
                                                        @InnerPacks   = null,
                                                        @Quantity     = @vTotalQtyToReceive,
                                                        @NumLPNs      = @vLPNsPerPallet,
                                                        @UpdateOption = '+' /* Add */;
             end

          insert into @ttLPNs (EntityId)
            select @vLPNId;

          /* Setting to default values for next iteration. */
          select @vLPNId       = null,
                 @vFirstLPNId  = null,
                 @FirstLPNId   = null,
                 @vFirstLPN    = null,
                 @vLastLPNId   = null,
                 @vLastLPN     = null;

          select @vPalletCount = @vPalletCount - 1;
        end

      /* Update temp table by setting processed flag when particular receipt is processed */
      update @ttReceiptDetails
      set Processed = case when @ReturnCode = 0 then 'Y' /* Yes */ else 'N' /* No */ end
      where (ReceiptDetailId = @vReceiptDetailId);
    end;

  /* Fetch the count of updated RO lines */
  select @vUpdatedRODetailCount = count(*),
         @vNumPalletReceived    = sum(NumPallets),
         @vNumLPNsReceived      = sum(LPNsPerPallet),
         @vNumUnitsReceived     = sum(QtyPerLPN)
  from @ttReceiptDetails
  where (Processed = 'Y' /* Yes */);

  /* Updating Counts of Location and ReceiptHeaders */
  exec @ReturnCode = pr_Locations_UpdateCount @LocationId = @vLocationId;

  /* Recount & set status of ROH */
  exec pr_ReceiptHeaders_Recount @vReceiptId;

  /* Build xml list of LPNs that have been generated for label printing on UI */
  set @xmlLPNsGenerated = (select L.LPN
                           from LPNs L
                             join @ttLPNs TL on (L.LPNId = TL.EntityId)
                           group by L.PalletId, L.LPN
                           for xml path(''), root('LPNs')) ;

   if (coalesce(@vPalletId, 0) > 0)
    begin
      /* Logging AT on Receipt */
       exec pr_AuditTrail_Insert 'CreateLPNs_Pallet', @UserId, null /* ActivityTimestamp */,
                                    @BusinessUnit  = @BusinessUnit,
                                    @ReceiverId    = @vReceiverId,
                                    @ReceiptId     = @vReceiptId,
                                    @ToPalletId    = @vPalletId,
                                    @SKUId         = @vSKUId,
                                    @NumPallets    = @vNumPalletReceived,
                                    @InnerPacks    = @vInnerPacks,
                                    @Quantity      = @vQtyPerLPN,
                                    @LocationId    = @vLocationId,
                                    @NumLPNs       = @vNumLPNsReceived;

      /* Building success or failure message into XML */
      if (@vNumLPNsReceived = 1)
        exec @vMessage = dbo.fn_Messages_Build 'CreateLPNsToReceive_Pallet1', @vFirstLPN, @vQtyPerLPN, @vSKU, @vPallet;
      else
        begin
          /* We have only 5 params for build so combine SKU & Pallet into one param */
          select @vSKUAndPallet = @vSKU + ' onto pallet ' + @vPallet;
          exec @vMessage = dbo.fn_Messages_Build 'CreateLPNsToReceive_Pallet', @vNumLPNsReceived, @vFirstLPN, @vLastLPN, @vQtyPerLPN, @vSKUAndPallet;
        end
    end
  else
    begin
      exec pr_AuditTrail_Insert 'CreateLPNs', @UserId, null /* ActivityTimestamp */,
                                 @BusinessUnit  = @BusinessUnit,
                                 @ReceiverId    = @vReceiverId,
                                 @ReceiptId     = @vReceiptId,
                                 @SKUId         = @vSKUId,
                                 @InnerPacks    = @vInnerPacks,
                                 @Quantity      = @vQtyPerLPN,
                                 --@ToLocationId  = @vLocationId,
                                 @NumLPNs       = @vNumLPNsReceived;
      if (@vNumLPNsReceived = 1)
        exec @vMessage = dbo.fn_Messages_Build 'CreateLPNsToReceive1', @vFirstLPN, @vQtyPerLPN, @vSKU;
      else
        exec @vMessage = dbo.fn_Messages_Build 'CreateLPNsToReceive', @vNumLPNsReceived, @vFirstLPN, @vLastLPN, @vQtyPerLPN, @vSKU;
    end

  /* Updating output XML, Need to use a function which will build XML. For now we are framing XML in set statement */
  set @xmlResult = '<ReceivingDetails xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><Response><Status>Success</Status><ResponseMessage>' + @vMessage + '</ResponseMessage></Response>' + @xmlLPNsGenerated + '</ReceivingDetails>';

  commit transaction;

ErrorHandler:
  if (@MessageName is not null)
    begin
      exec @vMessage = fn_Messages_Build @MessageName;
      /* Updating output XML */
      set @xmlResult = '<ReceivingDetails xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><Response><Status>Failed</Status><ResponseMessage>' + @vMessage + '</ResponseMessage></Response></ReceivingDetails>';
      exec pr_ReRaiseError;
    end

end try
begin catch
  if (coalesce(@xmlResult, '') = '')
    begin
      select @vMessage = ERROR_MESSAGE();
      set @xmlResult = '<ReceivingDetails xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"><Response><Status>Failed</Status><ResponseMessage>' + @vMessage + '</ResponseMessage></Response></ReceivingDetails>';
    end

  if (@@trancount > 0) rollback transaction;
end catch

ExitHandler:
  return(coalesce(@ReturnCode, 0));
end /* pr_Receipts_UI_ReceiveToLPN */

Go
