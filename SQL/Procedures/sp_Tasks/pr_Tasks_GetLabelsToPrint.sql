/*------------------------------------------------------------------------------
  Copyright (c) Foxfire Technologies (India) Ltd.  All rights reserved

  Revision History:

  Date        Person  Comments

  2020/03/13  TK      pr_Tasks_GetLabelsToPrint: Get the range of LPNs generated by LPN instead of LPNId (S2GCA-1110)
  2019/08/21  AY      pr_Tasks_GetHeaderLabelData/pr_Tasks_GetLabelsToPrint: Set LabelPrinted flag on printing instead of when data is shown to user (CID-976)
  pr_Tasks_GetLabelsToPrint: Made changes to update PrintedTime and removed code for LabelsPrinted (OB2-898)
  2019/05/21  YJ      pr_Tasks_GetLabelsToPrint: Changes to not consider canceled temp-labels (CID-366)
  2018/07/14  RT      pr_Tasks_GetLabelsToPrint: Made changes to print the Packing list with respect to the Pacakage Seq no (S2GCA-61)
  2018/04/24  TK      pr_Tasks_GetLabelsToPrint: Changes to print UCC Labels (S2G-735)
  TK      pr_Tasks_GetLabelsToPrint: Changes to print packing list for PTLC waves (S2G-620)
  2017/06/09  PSK     pr_Tasks_SetStatus,pr_Tasks_GetLabelsToPrint: Updated "StartTime","EndTime", and "WaveGroup" fields (CIMS-1400)
  2017/05/23  VM      pr_Tasks_GetLabelsToPrint: Need to print SL as well for PTS DropShip Wave groups (SRI-750)
  2017/04/20  KN      pr_Tasks_GetLabelsToPrint returning checkbox list (HPI-635)
  2016/08/11  KN      pr_Tasks_GetLabelsToPrint added code to set IsPrintable=N if task status is cancelled  (HPI-303)
  2016/08/04  PK      pr_Tasks_GetLabelsToPrint: Updating the labelsPrinted flag on the tasks.(HPI-408)
  pr_Tasks_GetLabelsToPrint: Changes made to print Employee Labels form Tasks page (HPI-379)
  2016/06/29  TK      pr_Tasks_GetLabelsToPrint: Enhanced for Pick & Pack waves (HPI-162)
  2016/06/16  TK      pr_Tasks_GetLabelsToPrint: Enhanced to print multi labels from Tasks Page (NBD-578)
  2015/11/16  TK      pr_Tasks_GetLabelsToPrint: Bug fix to avoid re-printing of LPN Labels when selected multiple Tasks to print(ACME-408)
  2015/10/20  SV      pr_Tasks_GetLabelsToPrint: Resolved the issue with sigature change of a type (ACME-313)
  2015/08/14  TK      pr_Tasks_GetLabelsToPrint: Release Tasks when user prints Task Labels (ACME-293)
  2015/07/30  TK      pr_Tasks_GetLabelsToPrint: Task Sub type is LPN Pick then directly get the distinct LPNs from TaskDetails(ACME-267)
  2015/07/12  AY      pr_Tasks_GetLabelsToPrint: Print label formats as specified in rules
  2015/05/11  DK      pr_Tasks_GetLabelsToPrint: Modified to print PackingList along with labels.
  2014/04/24  PK      Added pr_Tasks_GetLabelsToPrint.
------------------------------------------------------------------------------*/

Go

if object_id('dbo.pr_Tasks_GetLabelsToPrint') is not null
  drop Procedure pr_Tasks_GetLabelsToPrint;
Go
/*------------------------------------------------------------------------------
  Proc pr_Tasks_GetLabelsToPrint: Returns all the info associated with the
    label formats to be printed for a Task.
------------------------------------------------------------------------------*/
Create Procedure pr_Tasks_GetLabelsToPrint
  (@BatchNo             TPickBatchNo = null,
   @Tasks               XML          = null,
   @LabelPrintSortOrder TLookUpCode,
   @PrinterName         TDeviceId,
   @UserId              TUserId,
   @BusinessUnit        TBusinessUnit)
as
  declare @vReturnCode          TInteger,
          @vMessageName         TMessageName,
          @vMessage             TDescription,

          @vRecordId            TRecordId,
          @vDocRecId            TRecordId,
          @vDocToPrint          TEntityKey,
          @vWaveNo              TPickBatchNo,
          @vWaveType            TTypeCode,
          @vBParentRecordId     TRecordId,
          @vTParentRecordId     TRecordId,
          @vTaskId              TRecordId,
          @vTaskStatus          TStatus,
          @vTaskSubType         TTypeCode,
          @vIsTaskAllocated     TFlag,
          @vIsTaskConfirmed     TFlag,
          @vDestZone            TZoneId,
          @vWaveGroup           TWaveGroup,

          @vLPNId               TRecordId,
          @vFirstLPNId          TRecordId,
          @vLastLPNId           TRecordId,
          @vFirstLPN            TLPN,
          @vLastLPN             TLPN,
          @vDestWarehouse       TWarehouse,
          @vOrderId             TRecordId,
          @vOrderType           TTypeCode,
          @vOrderCount          TCount,
          @vOrderTypeDesc       TDescription,
          @vShiplabelFormat     TName,
          @vLabelType           TLookUpCode,
          @vIsPackingListRequired
                                TFlag,
          @vReleaseTasksOnPrint TFlag,
          @vIsPalletShipLabel   TControlCode,
          @vPLTypeToBePrinted   TControlValue,
          @vRuleDataXML         TXML,
          @vTaskLabelFormat     TName,
          @vDocumentsToPrint    TVarchar,

          @vDependencyFlags     TFlags,
          @vIsLabelGenerated    TFlags;

  declare @ttLPNsToPrint        TLabelsToPrint;
  declare @ttLPNLabelsToPrint   TLabelsToPrint;

  declare @ttLabelsToPrint  table
          (BatchNo          TPickBatchNo,
           TaskId           TRecordId,
           PickTicket       TPickTicket,
           Pallet           TPallet,
           LPN              TLPN,
           CustPO           TCustPO,
           ShipToStore      TShipToStore,
           EntityKey        varchar(50),
           LabelType        TLookUpCode,
           LabelFormatName  TName,
           Description      TDescription,
           IsPrintable      TFlag,
           Data             TXML,
           RecordId         Integer Identity(1,1),
           ParentRecordId   Integer);

  declare @ttTasks            TEntityKeysTable,
          @ttLabelTypes       TEntityKeysTable,
          @ttTasksGenerateTL  TEntityKeysTable,
          @ttDocumentsToPrint TEntityKeysTable;

begin /* pr_Tasks_GetLabelsToPrint */
  select @vReturnCode   = 0,
         @vMessagename  = null,
         @vRecordId     = 0;

  /* insert the user selected details into temp table */
  if (@BatchNo is not null) and (@Tasks is null)
    begin
      insert into @ttTasks (EntityId)
       select TaskId
       from Tasks
       where (BatchNo      = @BatchNo) and
             (BusinessUnit = @BusinessUnit);
    end
  else
    begin
      insert into @ttTasks (EntityId)
        select Record.Col.value('(./text())[1]', 'varchar(50)')
        from @Tasks.nodes('/Tasks/TaskId') as Record(Col);
    end

  /* Get the tasks for which temp labels are not yet generated and
     then generate them */
  insert into @ttTasksGenerateTL (EntityId)
    select distinct TD.TaskId
    from TaskDetails TD
      join @ttTasks TT on (TD.TaskId = TT.EntityId) and
                          (TD.IsLabelGenerated = 'T'/* Temp Label */);

  /* generate the temp labels for the tasks which have no temp labels */
  if (@@rowcount > 0)
    exec @vReturnCode = pr_Tasks_GenerateTempLabels @BatchNo,
                                                    @ttTasksGenerateTL,
                                                    null /* @TaskId */,
                                                    @BusinessUnit,
                                                    @UserId;

  /* begin loop to get the selected labels */
  while (exists (select * from @ttTasks where RecordId > @vRecordId))
    begin
      /* get the top 1 record from the temp table */
      select top 1 @vRecordId = RecordId,
                   @vTaskId   = EntityId
      from @ttTasks
      where (RecordId > @vRecordId)
      order by RecordId;

      /* get the batch no */
      select @vWaveNo          = BatchNo,
             @vWaveType        = BatchType,
             @vWaveGroup       = WaveGroup /* Wave Group */,
             @vTaskSubType     = TaskSubType,
             @vTaskStatus      = Status,
             @vOrderCount      = OrderCount,
             @vIsTaskAllocated = IsTaskAllocated,
             @vIsTaskConfirmed = IsTaskConfirmed,
             @vDestZone        = coalesce(DestZone, ''),
             @vDestWarehouse   = Warehouse,
             @vDependencyFlags = DependencyFlags
      from vwTasks
      where (TaskId = @vTaskId);

      /* Skip tasks which are canceled or which are dependent on Replenishment */
      if (@vTaskStatus = 'X' /* Canceled */) or (@vDependencyFlags = 'R' /* Replenishment */)
        continue;

      /* Build the XML for record with all data required for rules */
      select @vRuleDataXML = (select @vWaveNo       WaveNo,
                                     @vWaveType     WaveType,
                                     @vWaveGroup    WaveGroup,
                                     @vTaskSubType  PickType,
                                     @vTaskId       TaskId,
                                     @vDestZone     DestZone,
                                     ''             LabelType
                              for xml raw('RootNode'), elements);

      /* Determime the Documents to be printed */
      exec pr_RuleSets_Evaluate 'TasksReleaseOnPrint', @vRuleDataXML, @vReleaseTasksOnPrint output;

      /* Determine whether label generated or not */
      exec pr_RuleSets_Evaluate 'Task_GenerateLabels', @vRuleDataXML, @vIsLabelGenerated output;

      /* Release created tasks based on the control variable */
      if (@vReleaseTasksOnPrint = 'Y' /* Yes */)
        exec pr_Tasks_Release Default /* Tasks Table */, @vTaskId /* TaskId */ , null /* Batch No */, default /* Force Release */,
                              @BusinessUnit, @UserId;

      if (not exists(select * from @ttLabelsToPrint
                     where (BatchNo = @vWaveNo) and (LabelType = 'BL')))
        begin
          insert into @ttLabelsToPrint(BatchNo, EntityKey, Description, LabelType, IsPrintable)
            select @vWaveNo, @vWaveNo, 'Wave ' + @vWaveNo, 'BL', 'N'

          /* get the wave parent recordId */
          select @vBParentRecordId = Scope_Identity();
        end

      /* Initialize */
      set @vTParentRecordId = null;

      /* Clean up temp tables */
      delete from @ttLPNsToPrint;
      delete from @ttLPNLabelsToPrint;
      delete from @ttDocumentsToPrint;

      /* Determime the Documents to be printed */
      exec pr_RuleSets_Evaluate 'TaskDocumentsToPrint', @vRuleDataXML, @vDocumentsToPrint output;

      /* RuleSet would return comma separated values, convert them to dataset and insert
         into temp table for processing */
      insert into @ttDocumentsToPrint (EntityKey)
        select Value from dbo.fn_ConvertStringToDataSet(@vDocumentsToPrint, ',');

      set @vDocRecId = 0;

      while exists (select * from @ttDocumentsToPrint where RecordId > @vDocRecId)
        begin
          select top 1 @vDocRecId = RecordId,
                       @vDocToPrint = EntityKey
          from @ttDocumentsToPrint
          where (RecordId > @vDocRecId)
          order by RecordId;

          /* Check if Task Header Labels are to be printed */
          if (@vDocToPrint = 'TL' /* Task Header Label */)
            begin
              /* Determime the task label to print - if none is returned, then no header label would print */
              exec pr_RuleSets_Evaluate 'TaskLabelFormats', @vRuleDataXML, @vTaskLabelFormat output;

              /* For each task, the first label to print is the Task Header Label */
              insert into @ttLabelsToPrint(ParentRecordId, BatchNo, TaskId, EntityKey, Description,
                                           LabelType, LabelFormatName)
                select @vBParentRecordId, @vWaveNo, @vTaskId, @vTaskId, 'Batch '+ cast(@vTaskId as varchar),
                       @vDocToPrint, @vTaskLabelFormat;

              select @vTParentRecordId = Scope_Identity();
            end

          /* If Task Header label is not required then insert dummy record so that we can group labels together per batch */
          if (@vTParentRecordId is null)
            begin
              insert into @ttLabelsToPrint(ParentRecordId, BatchNo, TaskId, EntityKey, Description, IsPrintable)
                select @vBParentRecordId, @vWaveNo, @vTaskId, @vTaskId, 'Batch '+ cast(@vTaskId as varchar), 'N';

              select @vTParentRecordId = Scope_Identity();
            end

          /* Check if Task Header Labels are to be printed */
          if (@vDocToPrint = 'TDL' /* Task Detail Label */)
            begin
              set @vRuleDataXML = dbo.fn_XMLStuffValue (@vRuleDataXML, 'LabelType', @vDocToPrint);

              /* For each task, the first label to print is the Task Header Label */
              insert into @ttLabelsToPrint(TaskId, EntityKey, LabelType, LabelFormatName)
                exec pr_Tasks_GetDetailLabelsToPrint @vTaskId, @vDocToPrint, @vRuleDataXML;

              /* Update Task Parent RecordId */
              update @ttLabelsToPrint
              set ParentRecordId = @vTParentRecordId,
                  Description    = 'Employee Labels for Batch '  + cast(TaskId as varchar(max))
              where (LabelType = @vDocToPrint) and
                    (TaskId    = @vTaskId    );
             end

          /* Check if LPN Labels are to be printed */
          if (@vDocToPrint = 'LPN' /* New LPN Label */)
            begin
              /* Create blank/empty LPNs */
              exec pr_LPNs_Generate 'S'            /* LPNType, ShipCarton */,
                                    @vOrderCount   /* NumLPNsToCreate */,
                                    null           /* LPNFormat - Use default format based upon LPNType */,
                                    @vDestWarehouse,
                                    @BusinessUnit,
                                    @UserId,
                                    @vFirstLPNId output,
                                    @vFirstLPN   output,
                                    @vLastLPNId  output,
                                    @vLastLPN    output;

              insert into @ttLPNsToPrint (BatchNo, TaskId, LPNId, LPN, WaveType, LabelType)
                select @vWaveNo, @vTaskId, LPNId, LPN, @vWaveType, @vDocToPrint
                from LPNs
                where (LPN between @vFirstLPN and @vLastLPN) and
                      (LPNType = 'S'/* ShipCarton */) and
                      (BusinessUnit = @BusinessUnit)  and
                      (CreatedBy = @UserId)
                order by LPN;
            end

          /* Check if Ship Labels are to be printed */
          if (@vDocToPrint = 'SL' /* Ship Label */) or
             (@vDocToPrint = 'SPL' /* Small Package Label */) or
             (@vDocToPrint = 'CL' /* Contents Label */) or
             (@vDocToPrint = 'PL' /* Packing List */)
            begin
              /* If Task is a case pick task, there could be multiple LPNs per TaskDetail, so order them by PackageSeqNo */
              if (@vTaskSubType = 'CS')
                insert into @ttLPNsToPrint (BatchNo, TaskId, LPNId, LPN, OrderId, WaveType, LabelType, DocumentType, EntityType, BusinessUnit)
                  select LT.PickBatchNo, LT.TaskId, L.LPNId, L.LPN, L.OrderId, @vWaveType, @vDocToPrint, @vDocToPrint, 'LPN', LT.BusinessUnit
                  from LPNTasks LT
                    left outer join TaskDetails  TD  on (LT.TaskDetailId = TD.TaskDetailId)
                    join LPNs                    L   on (LT.LPNId        = L.LPNId)
                    left outer join Locations    LOC on (TD.LocationId   = LOC.LocationId)
                  where (LT.TaskId = @vTaskId) and (L.Status <> 'V' /* Voided */) /* TaskDetails can be canceled but task may not be canceled hence excluding */
                  order by L.PackageSeqNo, LOC.PickPath, TD.TaskDetailId, L.LPN;

              /* if Task Sub type is LPN Pick then directly get the distinct LPNs from TaskDetails and Print
                 if the wave type is Replenish then we don't need to print any labels and Packing Lists */
              if (@vTaskSubType = 'L'/* LPN */) and (@vWaveType not in ('R', 'RU', 'RP'))
                insert into @ttLPNsToPrint (BatchNo, TaskId, LPNId, LPN, OrderId, WaveType, LabelType, DocumentType, EntityType, BusinessUnit)
                  select distinct BatchNo, TaskId, LPNId, LPN, OrderId, @vWaveType, @vDocToPrint, @vDocToPrint, 'LPN', @BusinessUnit
                  from vwTaskDetails
                  where TaskId = @vTaskId and (Status <> 'X' /* Canceled */);

              /* If it is a Unit pick task, there could be multiple LPNs per TaskDetail, so order them by PickPath */
              if (@vTaskSubType = 'U') and (@vIsLabelGenerated = 'Y')
                insert into @ttLPNsToPrint (BatchNo, TaskId, LPNId, LPN, OrderId, WaveType, LabelType, DocumentType, EntityType, BusinessUnit)
                  select distinct LT.PickBatchNo, LT.TaskId, L.LPNId, L.LPN, L.OrderId, @vWaveType, @vDocToPrint, @vDocToPrint, 'LPN', @BusinessUnit
                  from LPNTasks LT
                    join LPNs   L   on (LT.LPNId = L.LPNId)
                  where (LT.TaskId = @vTaskId) and (L.Status <> 'V' /* Voided */);
            end
        end

      /* Now that we have all the LPNs to print, determine the label format to be printed for each of them */
      insert into @ttLPNLabelsToPrint (LoadNumber, BatchNo, PickTicket, Pallet, LPNId, LPN, TaskId, OrderId, CustPO, SoldToId, ShipToId,
                                       Carrier, ShipVia, ShipToStore, WaveType, LabelType, LabelFormatName, IsPrintable) -- table of records with Label format
        exec pr_ShipLabel_GetLabelFormat @ttLPNsToPrint; -- table of records without Label format

      /* Follow the header label with the individual labels for the temp labels. For
         Bulk/Replenish we would print LPN label, else we print Shipping Label */

      /* The joins have been changed below because when we create pseudo pick tasks, we do not have taskdetails
         for all picks in LPNTasks */
      insert into @ttLabelsToPrint(ParentRecordId, BatchNo, TaskId, EntityKey, LPN,-- PickTicket, CustPO, ShipToStore,
                                   LabelType, LabelFormatName, Description)
        select @vTParentRecordId, LTL.BatchNo, LTL.TaskId, LTL.LPN, LTL.LPN, -- OH.PickTicket, OH.CustPO, OH.ShipToStore,
               LTL.LabelType, LTL.LabelFormatName,
               case when LTL.LabelType = 'L'   then 'LPN '                   + LTL.LPN
                    when LTL.LabelType = 'PL'  then 'Packing List for LPN '  + LTL.LPN
                    when LTL.LabelType = 'SL'  then 'UCC Label for LPN '     + LTL.LPN
                    when LTL.LabelType = 'SPL' then 'Ship Label for LPN '    + LTL.LPN
               end
        from @ttLPNLabelsToPrint LTL
         -- join OrderHeaders OH  on (OH.OrderId = LTL.OrderId)
        where (TaskId = @vTaskId)
        order by LTL.RecordId;

        /* unassign the variable */
        select @vTaskId = null;
    end

  /* get the data set from the temp table and return to the caller */
  select RecordId       as KeyFieldName,
         ParentRecordId as ParentFieldName,
         EntityKey      as EntityKey,
         Description    as Description,
         /* Printable */
         case when (IsPrintable is not null) then IsPrintable
              when ((Description like 'L%') and (LabelFormatName is not null) and (@vIsPackingListRequired = 'Y')) then 'LP' /*Label, PackingList*/
             -- when ((LabelFormatName is not null)) then 'L' /*Label*/
              when ((LabelFormatName is not null) and (LabelType <> 'PL')) then 'L' /*Label*/
              when ((LabelFormatName is not null) and (LabelType = 'PL')) then 'P' /* PackingList*/
              else 'N'
         end            as IsPrintable,
         /* Data */
         coalesce(Data, dbo.fn_XMLNode('Root', dbo.fn_XMLNode('LabelFormatName', LabelFormatName))) as Data
  from @ttLabelsToPrint
  order by RecordId;

  /* get labeltypes to show in checkbox list and return to the caller */
  select distinct TR.LabelType as LookUpCode, L.LookUpDescription LookUpDescription
         from lookups L
         join  @ttLabelsToPrint TR on (L.LookUpCode = TR.LabelType)
  where  (L.LookUpCategory = 'LabelType') and
         (L.BusinessUnit= @BusinessUnit )

ErrorHandler:
  if (@vMessageName is not null)
    exec @vReturnCode = pr_Messages_ErrorHandler @vMessageName, @vOrderTypeDesc;

ExitHandler:
  return(coalesce(@vReturnCode, 0));
end /* pr_Tasks_GetLabelsToPrint */

Go
